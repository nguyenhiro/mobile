<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mario Đơn Giản (Tối ưu Mobile Ngang & Căn giữa)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Quan trọng: Ngăn thanh cuộn của body */
            background-color: #87ceeb;
            background-image: url('body.jpg'); /* Đường dẫn đến ảnh nền bạn muốn */
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center center;
            /* Sử dụng Flexbox để căn giữa game-container */
            display: flex;
            flex-direction: column; /* Quan trọng: Xếp game và controls theo cột */
            justify-content: center; /* Căn giữa theo chiều dọc (game-container + mobile-controls) */
            align-items: center;   /* Căn giữa theo chiều ngang */
            min-height: 100vh;
            width: 100vw; 
            box-sizing: border-box; 
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation; 
            font-family: 'Roboto', sans-serif;
            color: white;
        }

        #game-container {
            /* Kích thước gốc (tỷ lệ 2:1) - Đây là kích thước logic của game */
            width: 900px; 
            height: 450px;
            border: 5px solid #333;
            background-color: #aaddff;
            position: relative; 
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transform-origin: center center; 
            transform: scale(1); 
            transition: transform 0.1s ease-out; 
            
            /* Giới hạn kích thước trên PC, sử dụng tỷ lệ viewport lớn hơn để game to hơn */
            max-width: 98vw; /* Tăng từ 95vw lên 98vw */
            max-height: 98vh; /* Tăng từ 95vh lên 98vh */
            /* Điều này giúp game không bị quá to trên màn hình lớn và tự động co giãn */
        }

        #game-world {
            position: absolute;
            top: 0;
            left: 0;
            width: 2500px; /* Chiều rộng thế giới game */
            height: 100%;
            transition: transform 0.1s linear;
            background-image: url('game.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center bottom;
        }

        #player {
            width: 60px;
            height: 60px;
            background-image: url('https://www.pngall.com/wp-content/uploads/5/Pokemon-Pikachu-PNG-High-Quality-Image.png');
            background-size: contain;
            background-position: center bottom;
            background-repeat: no-repeat;
            position: absolute;
            image-rendering: pixelated;
            z-index: 10;
            transition: transform 0.1s ease-out; 
        }

        #player.flipped {
            transform: scaleX(-1);
        }

        .platform {
            background-image: url('dat2.png');
            background-size: cover;
            background-repeat: repeat-x;
            position: absolute;
            height: 50px;
            z-index: 5;
        }

        .obstacle, .hazard, .moving-obstacle {
            background-color: #8B4513;
            position: absolute;
            background-image: url('khucgo.jpg');
            background-size: cover;
            background-repeat: repeat-x;
            border: 2px solid #555;
            z-index: 6;
        }
        .hazard {
            background-color: #ffffff;
            border: 2px solid #8B0000;
            background-image: url('lua4-1.png');
            background-size: cover;
            background-repeat: repeat-x;
            border: none;
            z-index: 6;
        }
        .moving-obstacle {
            background-color: #56e6ff;
            border: 2px solid #333;
            background-image: url('may1-1.png');
            background-size: cover;
            background-repeat: repeat-x;
            z-index: 6;
        }

        #finish-line {
            width: 30px;
            height: 120px;
            background-color: rgb(92, 51, 4);
            position: absolute;
            background-image: url('cua-cong-2.png');
            background-size: cover;
            background-repeat: repeat-x;
            border: 2px dashed #000;
            z-index: 7;
        }

        #time-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: 'Roboto', sans-serif;
            font-weight: bold;
            font-size: 1.2em; 
            color: white;
            text-shadow: 2px 2px 3px black;
            z-index: 20;
            pointer-events: none; 
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 60px;
            border-radius: 15px;
            font-family: 'Roboto', sans-serif;
            font-size: 2.2em;
            display: none;
            z-index: 100;
            text-align: center;
            border: 3px solid #ffcc00;
            text-shadow: 2px 2px 5px black;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.6);
            width: 80%; 
            max-width: 600px;
            box-sizing: border-box;
            /* Thêm pointer-events để nút chơi lại hoạt động */
            pointer-events: auto; 
        }
        #game-message p {
            margin-bottom: 1.5vw;
            font-size: 0.8em;
            font-weight: bold;
        }
        #game-message ul {
            list-style: none;
            padding: 0;
            margin-top: 1vw;
            font-size: 0.6em;
            max-height: 10vh; 
            overflow-y: auto;
            border-top: 1px dashed rgba(255,255,255,0.3);
            padding-top: 1vw;
        }
        #game-message li {
            margin-bottom: 0.3vw;
        }

        #reset-button {
            margin-top: 2vw;
            padding: 1vw 2vw; 
            font-size: 1.2em; 
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s, transform 0.2s;
            font-family: 'Roboto', sans-serif;
            /* Đảm bảo nút này có thể được click */
            pointer-events: auto; 
        }
        #reset-button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }

        /* Nút điều khiển cảm ứng (Mobile only) */
        #mobile-controls {
            /* Bỏ position: fixed để nó nằm dưới game-container trong flexbox */
            /* position: fixed; */ 
            margin-top: 15px; /* Khoảng cách từ game-container */
            width: 90%; /* Chiếm 90% chiều rộng của body (khi căn giữa) */
            max-width: 600px; /* Giới hạn kích thước tối đa giống game-message */
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px; 
            border-radius: 15px;
            opacity: 0.9;
            /* Bỏ left, transformX vì body flexbox đã căn giữa */
            /* left: 50%; */
            /* transform: translateX(-50%); */
            display: none; /* Mặc định ẩn, JS sẽ điều khiển */
            box-sizing: border-box;
            gap: 15px; 
            pointer-events: auto; /* Đảm bảo nút này có thể được click */
        }
        .control-group {
            display: flex;
            /* Tăng khoảng cách giữa các nút trái/phải */
            gap: 20px; /* Tăng từ 10px lên 20px */
        }
        .control-button {
            width: 13vw; 
            height: 13vw; 
            max-width: 70px; 
            max-height: 70px; 
            min-width: 50px; /* Tăng từ 45px lên 50px để nút to hơn */
            min-height: 50px; 
            
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 5vw; 
            max-font-size: 30px; 
            min-font-size: 24px; /* Tăng từ 22px lên 24px */

            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 5px 10px rgba(0,0,0,0.3);
            transition: background-color 0.2s, transform 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .control-button:active {
            background-color: #0056b3;
            transform: scale(0.9); 
        }

        /* MEDIA QUERIES để tinh chỉnh font size và padding dựa trên kích thước màn hình */
        /* Cho màn hình rất nhỏ (dưới 480px, thường là điện thoại dọc) */
        @media (max-width: 480px) {
            #time-display {
                font-size: 1.1em; 
                top: 5px;
                left: 5px;
            }
            #game-message {
                padding: 20px;
                font-size: 1.5em; 
            }
            #game-message p {
                font-size: 1em;
            }
            #game-message ul {
                font-size: 0.8em;
            }
            #reset-button {
                font-size: 1em;
                padding: 10px 20px;
            }
            .control-button {
                width: 55px; /* Tăng kích thước nút cho mobile nhỏ */
                height: 55px;
                font-size: 26px;
            }
            .control-group {
                gap: 15px; /* Giảm khoảng cách cho mobile nhỏ */
            }
        }

        /* Cho màn hình trung bình (tablet, điện thoại ngang) */
        @media (min-width: 481px) and (max-width: 999px) {
            #time-display {
                font-size: 1.2em;
                top: 10px;
                left: 10px;
            }
            #game-message {
                padding: 30px;
                font-size: 2em;
            }
            #game-message p {
                font-size: 0.9em;
            }
            #game-message ul {
                font-size: 0.7em;
            }
            #reset-button {
                font-size: 1.1em;
                padding: 12px 25px;
            }
             .control-button {
                width: 60px; /* Tăng kích thước nút cho tablet/mobile ngang */
                height: 60px;
                font-size: 28px;
            }
            .control-group {
                gap: 20px; 
            }
        }

        /* Cho màn hình lớn (PC) */
        @media (min-width: 1000px) {
            #time-display {
                font-size: 1.3em;
                top: 15px;
                left: 15px;
            }
            #game-message {
                padding: 40px;
                font-size: 2.2em;
            }
            #game-message p {
                font-size: 0.9em;
            }
            #game-message ul {
                font-size: 0.7em;
            }
            #reset-button {
                font-size: 1.2em;
                padding: 15px 30px;
            }
            /* Trên PC, không cần mobile controls */
            #mobile-controls {
                display: none !important; 
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-world">
            <div id="player"></div>
            <div id="finish-line"></div>
        </div>
    </div>

    <div id="time-display">Thời gian: 00:00</div>
    <div id="game-message">
        <p>Bạn đã chiến thắng!</p>
        <button id="reset-button">Chơi Lại</button>
    </div>

    <div id="mobile-controls">
        <div class="control-group">
            <button class="control-button" id="left-button">←</button>
            <button class="control-button" id="right-button">→</button>
        </div>
        <button class="control-button" id="jump-button">↑</button>
    </div>

    <script>
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('game-container');
        const gameWorld = document.getElementById('game-world');
        const finishLine = document.getElementById('finish-line');
        const gameMessage = document.getElementById('game-message');
        const timeDisplay = document.getElementById('time-display');

        // Mobile Controls elements
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const jumpButton = document.getElementById('jump-button');

        let startTime = 0;
        let elapsedTime = 0;
        let timerInterval;

        let winHistory = JSON.parse(localStorage.getItem('gameWinHistory')) || [];

        let playerX = 50;
        let playerY = 0;
        const playerBaseWidth = 60;
        const playerBaseHeight = 60;
        let playerActualWidth = playerBaseWidth;
        let playerActualHeight = playerBaseHeight;

        const hitboxXOffset = 10; 
        const hitboxYOffset = 5; 

        const deathFallThreshold = -100; 

        let isJumping = false;
        let isMovingLeft = false;
        let isMovingRight = false;
        let isGameOver = false;
        let isOnPlatform = false; 

        const moveAcceleration = 1.2;
        const friction = 0.8;
        const maxSpeed = 6;
        const jumpStrength = 14;
        const gravity = 0.6;
        let xVelocity = 0;
        let yVelocity = 0;

        let cameraX = 0;
        let facingRight = true;

        let lastFrameTime = 0;
        const targetFPS = 60;

        let gameElements = [];
        let movingObstacles = [];

        // Kích thước game gốc (reference size)
        const gameBaseWidth = 900;
        const gameBaseHeight = 450;
        const gameAspectRatio = gameBaseWidth / gameBaseHeight; // 2:1

        // --- CÁC GIỚI HẠN MỚI ---
        const minGameScale = 0.7; // Scale tối thiểu cho game (tăng từ 0.6 để mobile ngang to hơn)
        const maxGameScale = 1.4; // Scale tối đa cho game (tăng từ 1.2 để PC to hơn)
        // Chúng ta sẽ dựa vào max-width/max-height của game-container trong CSS để kiểm soát kích thước lớn trên PC

        // Hàm điều chỉnh kích thước game container cho responsive
        function resizeGame() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let scale = 1;
            const viewportAspectRatio = viewportWidth / viewportHeight;

            if (viewportAspectRatio > gameAspectRatio) {
                // Viewport rộng hơn game (có khoảng trống ở hai bên)
                scale = viewportHeight / gameBaseHeight;
            } else {
                // Viewport hẹp hơn hoặc bằng game (có khoảng trống ở trên/dưới)
                scale = viewportWidth / gameBaseWidth;
            }

            // --- Áp dụng giới hạn cho scale ---
            scale = Math.min(scale, maxGameScale);
            scale = Math.max(scale, minGameScale);

            // Áp dụng scale cho game container
            gameContainer.style.transform = `scale(${scale})`;
            
            // Ẩn/hiện mobile controls dựa trên tỷ lệ game và kích thước viewport
            const mobileControls = document.getElementById('mobile-controls');
            // Nếu tỷ lệ game nhỏ (ví dụ: đang chơi trên mobile dọc) HOẶC nếu chiều rộng viewport không quá lớn (ví dụ dưới 1000px, phù hợp cho mobile ngang và tablet)
            if (scale < 1.0 || viewportWidth < 1000) { 
                mobileControls.style.display = 'flex';
            } else {
                mobileControls.style.display = 'none';
            }
        }

        // Gọi resizeGame khi tải trang và khi cửa sổ thay đổi kích thước
        window.addEventListener('resize', resizeGame);


        function createLevel(levelData) {
            gameElements.forEach(el => el.remove());
            gameElements = [];
            movingObstacles = [];

            finishLine.style.left = levelData.finishLine.left + 'px';
            finishLine.style.bottom = levelData.finishLine.bottom + 'px';
            finishLine.style.width = levelData.finishLine.width + 'px';
            finishLine.style.height = levelData.finishLine.height + 'px';

            levelData.elements.forEach(data => {
                const el = document.createElement('div');
                el.classList.add(data.type);
                el.style.left = data.left + 'px';
                el.style.bottom = data.bottom + 'px';
                el.style.width = data.width + 'px';
                el.style.height = data.height + 'px';
                gameWorld.appendChild(el);
                gameElements.push(el);

                if (data.type === 'moving-obstacle') {
                    movingObstacles.push({
                        element: el,
                        initialLeft: data.left,
                        range: data.range,
                        speed: data.speed,
                        direction: 1 
                    });
                }
            });
        }

        const level1Data = {
            worldWidth: 2500,
            finishLine: { left: 2450, bottom: 50, width: 30, height: 120 },
            elements: [
                { type: 'platform', left: 0, width: 200, height: 50, bottom: 0 },
                { type: 'platform', left: 300, width: 100, height: 50, bottom: 0 },
                { type: 'platform', left: 500, width: 150, height: 50, bottom: 0 },
                { type: 'platform', left: 750, width: 120, height: 50, bottom: 80 },
                { type: 'platform', left: 950, width: 100, height: 50, bottom: 0 },
                { type: 'platform', left: 1150, width: 180, height: 50, bottom: 0 },
                { type: 'platform', left: 1400, width: 100, height: 50, bottom: 120 },
                { type: 'platform', left: 1600, width: 150, height: 50, bottom: 0 },
                { type: 'platform', left: 1850, width: 150, height: 50, bottom: 0 },
                { type: 'platform', left: 2100, width: 200, height: 50, bottom: 0 },
                { type: 'platform', left: 2400, width: 100, height: 50, bottom: 0 },

                { type: 'obstacle', left: 150, width: 50, height: 30, bottom: 50 },
                { type: 'obstacle', left: 550, width: 70, height: 60, bottom: 50 },
                { type: 'obstacle', left: 800, width: 50, height: 30, bottom: 130 },
                { type: 'obstacle', left: 1450, width: 50, height: 40, bottom: 170 },
                { type: 'obstacle', left: 1650, width: 80, height: 70, bottom: 50 },
                { type: 'obstacle', left: 2200, width: 50, height: 50, bottom: 50 },

                { type: 'hazard', left: 350, width: 30, height: 15, bottom: 50 },
                { type: 'hazard', left: 1000, width: 60, height: 15, bottom: 50 },
                { type: 'hazard', left: 1950, width: 40, height: 20, bottom: 50 },

                { type: 'moving-obstacle', left: 600, width: 60, height: 40, bottom: 100, range: 100, speed: 1.5 },
                { type: 'moving-obstacle', left: 1250, width: 80, height: 50, bottom: 50, range: 150, speed: 1.2 },
                { type: 'moving-obstacle', left: 1700, width: 50, height: 30, bottom: 100, range: 80, speed: 2 }
            ]
        };

        function updateTimer() {
            if (isGameOver) return;
            elapsedTime = performance.now() - startTime;
            const minutes = Math.floor(elapsedTime / 60000);
            const seconds = Math.floor((elapsedTime % 60000) / 1000);
            const milliseconds = Math.floor((elapsedTime % 1000) / 10);
            timeDisplay.textContent = `Thời gian: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;
        }

        function updatePlayerPosition() {
            player.style.left = playerX + 'px';
            player.style.bottom = playerY + 'px';

            if (xVelocity < 0 && facingRight) {
                player.classList.add('flipped');
                facingRight = false;
            } else if (xVelocity > 0 && !facingRight) {
                player.classList.remove('flipped');
                facingRight = true;
            }
        }

        function jump() {
            if (isOnPlatform) { 
                isJumping = true;
                yVelocity = jumpStrength;
                isOnPlatform = false; 
            }
        }

        function getElementRect(element) {
            const left = parseInt(element.style.left);
            const bottom = parseInt(element.style.bottom);
            const width = parseInt(element.style.width); 
            const height = parseInt(element.style.height); 
            const right = left + width;
            const top = bottom + height;
            return { left, right, bottom, top, width, height };
        }

        function checkCollisionsX() {
            if (isGameOver) return;
            
            const playerHitbox = {
                left: playerX + hitboxXOffset,
                right: playerX + playerActualWidth - hitboxXOffset,
                bottom: playerY + hitboxYOffset,
                top: playerY + playerActualHeight
            };

            gameElements.forEach(element => {
                const elementRect = getElementRect(element);

                const horizontalOverlap = playerHitbox.left < elementRect.right && playerHitbox.right > elementRect.left;
                const verticalOverlap = playerHitbox.top > elementRect.bottom && playerHitbox.bottom < elementRect.top;

                if (horizontalOverlap && verticalOverlap) {
                    if (element.classList.contains('hazard')) {
                        endGame('Bạn đã chạm chướng ngại vật nguy hiểm!');
                        return; 
                    }

                    if (element.classList.contains('obstacle') || element.classList.contains('moving-obstacle')) {
                        if (xVelocity > 0) { 
                            playerX = elementRect.left - (playerActualWidth - hitboxXOffset); 
                            xVelocity = 0;
                        } else if (xVelocity < 0) { 
                            playerX = elementRect.right - hitboxXOffset; 
                            xVelocity = 0;
                        }
                    }
                }
            });
        }
        
        function checkCollisionsY(previousPlayerY) {
            if (isGameOver) return; 

            let playerCurrentlyOnPlatform = false;
            let highestPlatformY = -Infinity; 

            const playerHitbox = {
                left: playerX + hitboxXOffset,
                right: playerX + playerActualWidth - hitboxXOffset,
                bottom: playerY + hitboxYOffset,
                top: playerY + playerActualHeight
            };
            
            // Va chạm từ dưới lên (đụng trần)
            if (yVelocity > 0) { 
                gameElements.forEach(element => {
                    if (element.classList.contains('platform') || element.classList.contains('obstacle') || element.classList.contains('moving-obstacle')) {
                        const elementRect = getElementRect(element);

                        const horizontalOverlap = (playerHitbox.right > elementRect.left && playerHitbox.left < elementRect.right);
                        
                        if (horizontalOverlap && 
                            (previousPlayerY + playerActualHeight) <= elementRect.bottom && 
                            (playerY + playerActualHeight) > elementRect.bottom) 
                        {
                            playerY = elementRect.bottom - playerActualHeight; 
                            yVelocity = 0; 
                            isJumping = true; 
                        }
                    }
                });
            }

            // Va chạm từ trên xuống (đứng trên platform)
            gameElements.forEach(element => {
                if (element.classList.contains('platform') || element.classList.contains('obstacle') || element.classList.contains('moving-obstacle')) {
                    const elementRect = getElementRect(element);

                    const horizontalOverlap = (playerHitbox.right > elementRect.left && playerHitbox.left < elementRect.right);

                    if (horizontalOverlap && 
                        yVelocity <= 0 && 
                        (previousPlayerY + hitboxYOffset) >= elementRect.top && 
                        (playerY + hitboxYOffset) <= elementRect.top) 
                    {
                        if (element.classList.contains('hazard')) {
                            endGame('Bạn đã chạm chướng ngại vật nguy hiểm!');
                            return; 
                        }

                        if (elementRect.top > highestPlatformY) {
                            highestPlatformY = elementRect.top;
                            playerCurrentlyOnPlatform = true;
                        }
                    }
                }
            });

            if (playerCurrentlyOnPlatform) {
                playerY = highestPlatformY - hitboxYOffset;
                yVelocity = 0;
                isJumping = false;
            } else {
                yVelocity -= gravity; 
            }
            
            isOnPlatform = playerCurrentlyOnPlatform; 

            if (playerY + hitboxYOffset < deathFallThreshold && !isGameOver) { 
                endGame('Bạn đã rơi xuống vực!');
                return; 
            }
        }

        function checkWin() {
            if (isGameOver) return; 

            const finishLineRect = getElementRect(finishLine);

            const playerHitbox = {
                left: playerX + hitboxXOffset,
                right: playerX + playerActualWidth - hitboxXOffset,
                bottom: playerY + hitboxYOffset,
                top: playerY + playerActualHeight
            };

            if (playerHitbox.left < finishLineRect.right &&
                playerHitbox.right > finishLineRect.left &&
                playerHitbox.bottom < finishLineRect.top &&
                playerHitbox.top > finishLineRect.bottom ) {

                endGame('Bạn đã chiến thắng!');
            }
        }

        function endGame(message) {
            isGameOver = true;
            clearInterval(timerInterval);

            let finalMessage = `<p>${message}</p>`;
            let newRecord = false;

            if (message.includes('chiến thắng')) {
                const finalTime = elapsedTime;
                winHistory.push(finalTime);
                winHistory.sort((a, b) => a - b);
                if (winHistory.length > 5) {
                    winHistory = winHistory.slice(0, 5);
                }
                localStorage.setItem('gameWinHistory', JSON.stringify(winHistory));

                const minutes = Math.floor(finalTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const milliseconds = Math.floor((elapsedTime % 1000) / 10);
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;

                finalMessage += `<p>Thời gian của bạn: ${formattedTime}</p>`;

                if (winHistory.length > 0 && finalTime === winHistory[0]) {
                    newRecord = true;
                }

                if (newRecord) {
                    finalMessage += `<p>Kỷ lục mới!</p>`;
                }
            }

            finalMessage += '<p>Lịch sử chiến thắng:</p><ul>';
            if (winHistory.length === 0) {
                finalMessage += '<li>Chưa có kỷ lục nào.</li>';
            } else {
                winHistory.forEach((time, index) => {
                    const minutes = Math.floor(time / 60000);
                    const seconds = Math.floor((time % 60000) / 1000);
                    const milliseconds = Math.floor((time % 1000) / 10);
                    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;
                    finalMessage += `<li>${index + 1}. ${formattedTime}</li>`;
                });
            }
            finalMessage += '</ul>';


            finalMessage += '<button id="reset-button">Chơi Lại</button>';
            gameMessage.innerHTML = finalMessage;
            gameMessage.style.display = 'block';

            const existingResetButton = document.querySelector('#game-message #reset-button');
            if (existingResetButton) {
                // Đảm bảo loại bỏ event listener cũ trước khi thêm cái mới để tránh trùng lặp
                existingResetButton.removeEventListener('click', initializeGame);
                existingResetButton.removeEventListener('touchend', initializeGame); // Thêm cho cảm ứng
            }
            // Thêm event listener cho cả click (PC) và touchend (cảm ứng)
            document.querySelector('#game-message #reset-button').addEventListener('click', initializeGame);
            document.querySelector('#game-message #reset-button').addEventListener('touchend', (e) => {
                e.preventDefault(); // Ngăn hành vi mặc định của touchend (như mouse click)
                initializeGame();
            });

            cancelAnimationFrame(window.animationFrameId);
        }

        function gameLoop(currentTime) {
            if (isGameOver) return;

            if (!lastFrameTime) lastFrameTime = currentTime; 
            const delta = (currentTime - lastFrameTime) / 1000; 
            lastFrameTime = currentTime;

            movingObstacles.forEach(obs => {
                const currentLeft = parseInt(obs.element.style.left);
                const maxLeft = obs.initialLeft + obs.range;
                const minLeft = obs.initialLeft;

                obs.element.style.left = currentLeft + (obs.speed * obs.direction * delta * 60) + 'px';

                if (obs.direction === 1 && parseInt(obs.element.style.left) >= maxLeft) {
                    obs.direction = -1;
                    obs.element.style.left = maxLeft + 'px'; 
                } else if (obs.direction === -1 && parseInt(obs.element.style.left) <= minLeft) {
                    obs.direction = 1;
                    obs.element.style.left = minLeft + 'px'; 
                }
            });

            if (isMovingLeft) {
                xVelocity = Math.max(-maxSpeed, xVelocity - moveAcceleration * delta * targetFPS);
            } else if (isMovingRight) {
                xVelocity = Math.min(maxSpeed, xVelocity + moveAcceleration * delta * targetFPS);
            } else {
                if (xVelocity > 0) {
                    xVelocity = Math.max(0, xVelocity - friction * delta * targetFPS);
                } else if (xVelocity < 0) {
                    xVelocity = Math.min(0, xVelocity + friction * delta * targetFPS);
                }
            }
            
            playerX += xVelocity;
            playerX = Math.max(0, Math.min(level1Data.worldWidth - playerActualWidth, playerX));
            checkCollisionsX(); 

            const previousPlayerY = playerY;
            playerY += yVelocity; 
            checkCollisionsY(previousPlayerY); 

            updatePlayerPosition();

            // Cập nhật logic camera để nó hoạt động với kích thước scaled
            const currentComputedStyle = window.getComputedStyle(gameContainer);
            const transformMatrix = new DOMMatrixReadOnly(currentComputedStyle.transform);
            const currentScale = transformMatrix.a; 

            const playerScreenX = playerX * currentScale + cameraX; 
            const gameContainerActualWidth = gameBaseWidth * currentScale; 

            const cameraThreshold = gameContainerActualWidth / 3; 

            if (playerScreenX > gameContainerActualWidth - cameraThreshold) {
                cameraX -= (playerScreenX - (gameContainerActualWidth - cameraThreshold));
            } 
            else if (playerScreenX < cameraThreshold) {
                cameraX += (cameraThreshold - playerScreenX);
            }

            // Giới hạn cameraX để không cuộn ra ngoài giới hạn của game world
            const maxCameraX = 0; 
            const minCameraX = -(level1Data.worldWidth * currentScale - gameContainerActualWidth); 

            cameraX = Math.min(maxCameraX, cameraX); 
            cameraX = Math.max(minCameraX, cameraX); 

            gameWorld.style.transform = `translateX(${cameraX}px)`;

            checkWin(); 

            window.animationFrameId = requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (event) => {
            if (isGameOver) return;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                event.preventDefault();
            }

            switch (event.code) {
                case 'KeyA':
                case 'ArrowLeft': 
                    isMovingLeft = true;
                    break;
                case 'KeyD':
                case 'ArrowRight': 
                    isMovingRight = true;
                    break;
                case 'Space':
                case 'ArrowUp': 
                    jump();
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (isGameOver) return;

            switch (event.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    isMovingLeft = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    isMovingRight = false;
                    break;
            }
        });

        // Event listeners for mobile controls (Touch events)
        leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); isMovingLeft = true; });
        leftButton.addEventListener('touchend', (e) => { e.preventDefault(); isMovingLeft = false; });
        rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); isMovingRight = true; });
        rightButton.addEventListener('touchend', (e) => { e.preventDefault(); isMovingRight = false; }); // Sửa lỗi: touchend phải reset isMovingRight
        jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
        jumpButton.addEventListener('touchend', (e) => { e.preventDefault(); }); 

        function initializeGame() {
            createLevel(level1Data);
            gameWorld.style.width = level1Data.worldWidth + 'px';

            playerX = 50;
            const initialPlatformTop = 50; 
            playerY = initialPlatformTop - hitboxYOffset + 1; 

            xVelocity = 0;
            yVelocity = 0;
            isJumping = false;
            isMovingLeft = false;
            isMovingRight = false;
            isGameOver = false;
            isOnPlatform = false; 

            playerActualWidth = playerBaseWidth;
            playerActualHeight = playerBaseHeight;
            player.classList.remove('crouching', 'in-air', 'flipped');
            facingRight = true;
            cameraX = 0; 

            gameMessage.style.display = 'none'; 

            startTime = performance.now();
            elapsedTime = 0;
            timeDisplay.textContent = 'Thời gian: 00:00.00';
            clearInterval(timerInterval); 
            timerInterval = setInterval(updateTimer, 10); 

            updatePlayerPosition(); 

            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }
            lastFrameTime = performance.now(); 
            window.animationFrameId = requestAnimationFrame(gameLoop); 
        }

        // Gọi resizeGame lần đầu khi trang tải xong
        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();
            resizeGame(); 
        });
    </script>
</body>
</html>
